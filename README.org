#+TITLE:       architecture.service-provider README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION: Framework for defining, introspecting and using services and providers of such
#+KEYWORDS:    common lisp, architecture, service, provider, framework
#+LANGUAGE:    en

* Introduction
  In software architectures, a common feature is parametrization of
  algorithms or protocols with higher order functions or classes and
  generic functions complying to a certain protocol. These places of
  potential variations can be thought of as requiring a certain
  service which can be provided by arbitrary providers (See [[*Java
  Service Provider Interface]] for a related approach).
  # are sometimes called "extension points".


  While Common Lisp supports these designs very well on a language
  level (via symbols naming functions, first class functions,
  =cl:make-instance=, etc.), it is often useful to go a little bit
  beyond these builtin features:
  * It is considered good practice to use something like
    =make-test-result-formatter= instead of letting clients call
    =cl:make-instance= directly.
  * It is sometimes desirable to be able to enumerate all known
    providers of a given service.
  * Compile-time analysis of provider instantiation requests can
    reveal errors early or enable transformation into more efficient
    code.
  * Service providers can be loaded lazily when they are instantiated.

  This systems adds first class services and service providers to
  facilitate use cases like the above while trying to avoid conceptual
  mismatches with the builtin mechanisms.

  #+ATTR_HTML: :alt "build status image" :title Build Status :align right
  [[https://travis-ci.org/scymtym/architecture.service-provider][https://travis-ci.org/scymtym/architecture.service-provider.svg]]

* Tutorial
** Defining a Service
   In the simplest case, a service is a named collection of providers
   with an optional documentation string:
   #+BEGIN_SRC lisp :results value :exports both
     (service-provider:define-service my-service
       (:documentation
        "Providers of this service do stuff."))
   #+END_SRC

   #+RESULTS:
   : #<STANDARD-SERVICE MY-SERVICE (0) {1007248B33}>

** Registering a Provider
   A provider of a service can be anything for which a method on
   =service-provider:make-provider=, and optionally
   =service-provider:make-provider-form=, is defined.

   For the common cases in which a provider instantiates a class or
   calls a functions, the builtin provider classes
   =service-provider:class-provider= and
   =service-provider:function-provider= can be used. The easiest way
   to register providers of these two kinds are the functions
   =service-provider:register-provider/class= and
   =service-provider:register-provider/function= respectively.

   For example, registering a class as a provider of a service can be
   accomplished like this:
   #+BEGIN_SRC lisp :results value :exports both
     (defclass my-class ()
       ((foo :initarg :foo)))

     (service-provider:register-provider/class 'my-service 'my-class)
   #+END_SRC

   #+RESULTS:
   : #<CLASS-PROVIDER MY-CLASS {1007325293}>

** Instantiating a Provider
   The primary way to instantiate a service provider is
   =service-provider:make-provider= which resembles =cl:make-instance=
   but takes a service and a provider designator instead of a class
   designator:
   #+BEGIN_SRC lisp :results value :exports both
     (service-provider:make-provider 'my-service 'my-class :foo 1)
   #+END_SRC

   #+RESULTS:
   : #<MY-CLASS {1007BCD683}>

** Introspecting a Service
   Introspection of services works much like CLOS introspection: after
   retrieving a service object, reader functions as well as
   =cl:describe= and =cl:documentation= can be applied to it:
   #+BEGIN_SRC lisp :results output :exports both
     (let ((service (service-provider:find-service 'my-service)))
       (print (list (service-provider:service-name service)
                    (service-provider:service-providers service)))
       (fresh-line)
       (describe service)
       (fresh-line)
       (print (documentation service t)))
   #+END_SRC

   #+RESULTS:
   :
   : (MY-SERVICE (#<CLASS-PROVIDER MY-CLASS {100EEF8AC3}>))
   : #1=#<STANDARD-SERVICE MY-SERVICE (1) {100ED79C73}>
   :
   : Providers:
   : #1=#<CLASS-PROVIDER MY-CLASS {100EEF8AC3}>
   :
   : "Providers of this service do stuff."

** TODO Efficiency Considerations
* Reference
* TODO Related Work
** Java Service Provider Interface
   See [[http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html][documentation of the ServiceLoader class]] for details.

   Differences:
   * =architecture.service-providers= does not tie services to classes
     (or interfaces); services and providers are identified by
     symbols (or lists of symbols).
   * Introspection is modeled after CLOS introspection, e.g.
     =cl:find-class=.
   * Documentation is modeled after and integrates =cl:defclass= and
     =cl:documentation=.
   * Redefinitions and class-changes of services and service providers
     are supported.
   * Support for compile-time error-detection and optimizations can be
     added.

* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
