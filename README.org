#+TITLE:       architecture.service-provider README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION: Framework for defining, introspecting and using services and providers of such
#+KEYWORDS:    common lisp, architecture, service, provider, framework
#+LANGUAGE:    en

* STARTED Introduction
  In software architectures, a common feature is parametrization of
  algorithms or protocols with higher order functions or classes and
  generic function complying to a certain protocol. These places of
  potential variations can be thought of as requiring a certain
  service which can be provided by arbitrary providers (See [[*Java
  Service Provider Interface]] for a related approach).
  # are sometimes called "extension points".


  While Common Lisp supports these designs very well on a language
  level (via symbols naming functions, first class functions,
  =cl:make-instance=, etc.), it is often useful to go a little bit
  beyond these builtin features:
  * It is considered good practice to use something like
    =make-test-result-formatter= instead of letting clients call
    =cl:make-instance= directly
  * It is sometimes desirable to be able to enumerate all known
    providers of a given service
  * Compile-time analysis of instantiation requests can reveal errors
    early or enable transformation into more efficient code
  * Lazy loading of service providers when they are instantiated

  This systems adds first class services and service providers to
  facilitate the above use cases while trying to avoid conceptual
  mismatches with the builtin mechanisms.
* Tutorial
** STARTED Defining a Service
   #+BEGIN_SRC lisp
     (service-provider:define-service my-service
       (:documentation
        "Providers of this service do stuff."))
   #+END_SRC
** STARTED Defining a Provider
   A provider of a service can be anything for which a method on
   =service-provider:make-provider=, and optionally
   =service-provider:make-provider-form=, is defined.

   For the common cases in which a provider instantiates a class or
   calls a functions, the builtin provider classes
   =service-provider:class-provider= and
   =service-provider:function-provider= can be used. The easiest way
   to register providers of these two kinds are the functions
   =service-provider:register-provider/class= and
   =service-provider:register-provider/function= respectively.

   For example, registering a class as a provider of a service can be
   accomplished like this:
   #+BEGIN_SRC lisp
     (defclass my-class ()
       ((foo :initarg :foo)))

     (service-provider:register-provider/class 'my-service 'my-class)
   #+END_SRC
** STARTED Instantiating a Provider
   The primary way to instantiate a service provider is
   =service-provider:make-provider= which resembles
   =cl:make-instance=:
   #+BEGIN_SRC lisp
     (service-provider:make-provider 'my-service 'my-class :foo 1)
   #+END_SRC
** STARTED Introspecting a Service
   Introspection of services works much like CLOS introspection:
   #+BEGIN_SRC lisp
     (let ((service (service-provider:find-service 'my-service)))
       (print (list (service-provider:service-name service)
                    (service-provider:service-providers service))))
   #+END_SRC
** TODO Efficiency Considerations
* Reference
* TODO Related Work
** Java Service Provider Interface
   See [[http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html][documentation of the ServiceLoader class]] for details.

   Differences:
   * =architecture.service-providers= does not tie services to classes
     (or interfaces); services and providers are identified by
     symbols.
   * Introspection is modeled after CLOS introspection, e.g.
     =cl:find-class=.
   * Documentation is modeled after and integrates =cl:defclass= and
     =cl:documentation=.
   * Redefinitions and class-changes of services and service providers
     are supported.
   * Support for compile-time error-detection and optimizations can be
     added.

* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
